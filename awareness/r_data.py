from __future__ import division
from math import ceil, floor, cos, sin, pi, sqrt, tanh, radians
from physics import polar, cartesian
from logics import probability
import threading
import time
import thread_template
import Queue
import socket
import cPickle
import bz2

class r_data(thread_template.ThreadTemplate):
	""" Relative is an object/thread/socket server that transmits relative
		perceptual data down a tcp socket. The reason we do this is to enable
		us to use many different interfaces on different computers to represent
		the data sent by our sensory devices.
	"""

	def __init__(self, s_queues, s_connects, s_conds, s_locks, s_sema):
		""" Standard initialisation creating a seperate thread. Note that we
			use two queues here. One to handle the thread commands, and one to
			handle our sensory data.
		"""
		thread_template.ThreadTemplate.__init__(self, s_queues, s_connects, s_conds, s_locks, s_sema)
		self.s_queues.create('r_data')
		# Socket server setup
		self.server_socket									= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.port											= 54320
		self.listen											= 5

		self.window											= {}
		# Window width and height (in mm)
		self.window['mmx']									= 10000
		self.window['mmy']									= 10000

		# Grid width and height (in cells)
		self.columns										= 100
		self.rows											= 100

		# Cell sizes
		self.cell											= {}
		self.cell['mmx']									= self.window['mmx'] / self.columns
		self.cell['mmy']									= self.window['mmy'] / self.rows
		# Define our center point (this is where the sensors are)
		self.center											= {}
		# Center in mm
		self.center['mmx']									= self.window['mmx'] / 2
		self.center['mmy']									= self.window['mmy'] / 2

		# Store information about the relative data
		self.grid_bz2										= ''
		self.grid_file										= 'memory/awareness/r_data.bz2'

		# Hold information about our current position
		self.position										= {}
		self.position['r']									= 0.0	# radius (in mm)
		self.position['a']									= 0.0	# azimuth (in radians)
		self.position['t']									= 0.0	# theta (in radians)

		# The position on the grid to start from. When we move from one grid to
		# another, we need a wat to tell at which position we entered. This is
		# to give us a return route. By default its the bottom middle point.
		self.origin											= {}
		self.origin['r']									= 0.0
		self.origin['a']									= 0.0
		self.origin['t']									= 0

		# FIXME:I really dont want to have to use a cartesian method in order
		#		to draw my map. A better option would be to store some values
		#		then when I get new data, expand my references from the center
		self.grid											= [[2.0 for col in range(self.columns)]
																for row in range(self.rows)]
		self.values											= []

	def run(self):
		""" We run our system in a loop to catch socket connections from the
			client program, and to handle our internal events generated by the
			system itself.
		"""
		self.setName('r_data')
		self.display('%s:\t\t\t\tStarting thread' % self.getName(), level=10)
		# Start our server listening
		self.server_socket.bind(("", self.port))
		self.server_socket.listen(self.listen)

		# Loop in the thread and wait for items in the queue
		while 1:
			self.available									= 0
			# Get information about where we are and what is around us
			values											= [0,-45,-90,45,90]
			self.s_queues.put('ultrasonic','scan',{'tell':'r_data','call':'set_values','points':cPickle.dumps(values)})
			self.s_queues.put('drive','get_position',{'tell':'r_data','call':'set_position'})
			self.parse_queue()
			client_socket, address							= self.server_socket.accept()
			# Wait until we have our new values before we send them to our
			# client. This stops to sonic queue from building up to much.
			# Remember we need to parse the queue or our self.available
			# variable will never be changed to true. This also makes it
			# possible to close while we wait for a response.
			while self.available != 2:
				self.parse_queue()
			self.set_hitpoints()
			grid_string										= bz2.compress(cPickle.dumps(self.grid))
			file_handle										= open(self.grid_file, 'w')
			file_handle.write(grid_string)
			file_handle.close()
			client_socket.send(grid_string)
			client_socket.close()

		# All done. Close the thread
		self.display('%s:\t\t\t\tClosing thread' % self.getName(), level=10)

	def set_position(self, values={}):
		""" Given a pickled list containing a list of dictionaries that contain
			a value, and angle, convert it into a proper list and save it under
			the self.value list to be used by the local awareness.
		"""
		self.position										= cPickle.loads(values)
		self.available										+= 1

	def set_values(self,values={}):
		""" Given a pickled list containing a list of dictionaries that contain
			a value, and angle, convert it into a proper list and save it under
			the self.value list to be used by the local awareness.
		"""
		results												= cPickle.loads(values)
		self.values											= results['values']
		self.available										+= 1

	def set_hitpoints(self):
		""" This method reads the values and position and tries to calculate
			which cells have and dont have objects in them. We do this by
			adding the hits to the position, then for every divisor of our
			accuracy, we place a no hit in that cell. If we already have a hit
			in that cell, we increase the probability of it being true.
		"""
		# Start by finding which cell our reading starts at.
		pos_x, pos_y										= polar.to_cartesian(self.position['r'], self.position['a'])
		pos_t												= self.position['t']

		# place this cell on the grid
		print 'Xp: %s Xc: %s' % (pos_x, ceil(pos_x/self.cell['mmx']))
		print 'Yp: %s Yc: %s' % (pos_y, ceil(pos_y/self.cell['mmy']))
		self.grid[50][50]									= 0.0
