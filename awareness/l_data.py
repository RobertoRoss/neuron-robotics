from __future__ import division
from math import radians, cos, sin, pi, sqrt, ceil
import threading
import time
import thread_template
import Queue
import socket
import cPickle

class l_data(thread_template.ThreadTemplate):
	""" Local is an object/thread/socket server that transmits local perceptual
		data down a tcp socket. The reason we do this is to enable us to use
		many different interfaces on different computers to represent the data
		sent by our sensory devices.
	"""

	def __init__(self, s_queues, s_connects, s_conds, s_locks, s_sema):
		""" Standard initialisation creating a seporate thread. Note that we
			use two queues here. One to handle the thread commands, and one to
			handle our sensory data.
		"""
		thread_template.ThreadTemplate.__init__(self, s_queues, s_connects, s_conds, s_locks, s_sema)
		self.s_queues.create('l_data')
		# Socket server setup
		self.server_socket									= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.port											= 54321
		self.listen											= 5
		self.values											= []
		# Maximum sensor reading (in mm)
		self.max_value										= 2550
		self.values											= []
		# Grid size (in cells)
		self.columns										= 25
		self.rows											= 25
		# Set the grid margin (in px)
		self.margin											= {}
		self.margin['x']									= 20
		self.margin['y']									= 20
		self.window											= {}
		# Grid width and height (in pixels)
		self.window['gx']									= 250
		self.window['gy']									= 250
		# Windows true width and height with margin (in pixels)
		self.window['tx']									= self.window['gx'] + (2*self.margin['x'])
		self.window['ty']									= self.window['gy'] + (2*self.margin['y'])
		# Cell sizes
		self.cell											= {}
		# The width and height of cells (in pixels)
		self.cell['pxx']									= self.window['gx'] / self.columns
		self.cell['pxy']									= self.window['gy'] / self.rows
		self.cell['mmx']									= (self.max_value * 2.0) / self.columns
		self.cell['mmy']									= (self.max_value * 2.0) / self.rows
		# Define our center point (this is where the sensors are)
		self.center											= {}
		# Center in mm
		self.center['mmx']									= self.max_value
		self.center['mmy']									= self.max_value
		# Center in cells
		self.center['cx']									= ceil(self.columns / 2.0 - 1)
		self.center['cy']									= ceil(self.rows / 2.0 - 1)

		self.grid											= [[0.5 for col in range(self.columns)]
																for row in range(self.rows)]

	def run(self):
		""" We run our system in a loop to catch socket connections from the
			client program, and to handle our internal events generated by the
			system itself.
		"""
		self.setName('l_data')
		self.display('%s:\t\t\t\tStarting thread' % self.getName(), level=10)
		# Start our server listening
		self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		self.server_socket.bind(("", self.port))
		self.server_socket.listen(self.listen)

		# Loop in the thread and wait for items in the queue
		while 1:
			self.available									= False
			values											= [0,-45,-90,45,90]
			self.s_queues.put('ultrasonic','scan',{'tell':'l_data','call':'set_values','points':cPickle.dumps(values)})
			self.parse_queue()
			client_socket, address							= self.server_socket.accept()
			# Wait until we have our new values before we send them to our
			# client. This stops to sonic queue from building up to much.
			# Remember we need to parse the queue or our self.available
			# variable will never be changed to true. This also makes it
			# possible to close while we wait for a response.
			while not self.available:
				self.parse_queue()
			client_socket.send(cPickle.dumps(self.grid))
			client_socket.close()

		# All done. Close the thread
		self.display('%s:\t\t\t\tClosing thread' % self.getName(), level=10)

	def set_values(self, values={}):
		""" Given a pickled list containing a list of dictionaries that contain
			a value, and angle, convert it into a proper list and save it under
			the self.value list to be used by the local awareness.
		"""
		results												= cPickle.loads(values)
		self.max_value										= results['max_range']
		self.values											= results['values']
		self.grid											= [[0.5 for col in range(self.columns)]
																for row in range(self.rows)]
		self.sensorHits()
		self.available										= True

	def get_data(self, tell='g_data', call='get_l_data'):
		""" This method return the data (grid, cell, columns, rows) to the
			calling thread. It places the requested data on a stack so we can
			use the data to generate other mapping grids.
		"""
		values												= {}
		values['cell']										= self.cell
		values['grid']										= self.grid
		values['columns']									= self.columns
		values['rows']										= self.rows
		self.s_queues.put(tell,call,{'values':cPickle.dumps(values)})

	def inRange(self, rows, columns):
		""" Check if a hit value is within range
		"""
		return rows >= 0 and rows < self.rows and columns >= 0 and columns < self.columns

	def sensorHits(self):
		""" Point (0,0) is located at the center of the robot.
			Point (offx, offy) is the location of the sensor on the robot.
			Theta is angle of the sensor hit relative to heading 0.
			Dist is the distance of the hit from the sensor.
			Given these values, need to calculate the location of the hit
			relative to the center of the robot (hitx, hity).

							.(hitx, hity)
						   /
						  /
						 /
				   dist /
					   /
					  /
					 /theta
					.-------
				(offx, offy)
				.-->heading 0
				(0,0)
		"""
		for i in range(len(self.values)):
			# Check that the distance is less than the max range
			dist											= self.values[i]['value']
			if dist < self.max_value:
				rebound										= 1
			else:
				rebound										= 0

			hitx											= cos(radians(self.values[i]['angle'])) * dist
			hity											= sin(radians(self.values[i]['angle'])) * dist

			self.computeOccupancy(hitx, hity, rebound)

	def computeOccupancy(self, hitx, hity, rebound):
		"""
		Initially only compute occupancies on the line from the robot to
		the sensor hit.
		"""
		# set the origin of sensor empty:
		self.setGridLocation(0, 0, 2.0)

		# Calculate y value
		rise												= hity - self.center['cy']
		if abs(rise) < 0.1:
			rise											= 0

		# Calculate x value
		run													= hitx - self.center['cx']
		if abs(run) < 0.1:
			run												= 0

		steps												= int(round(max(abs(rise/self.cell['mmx']),
																				abs(run/self.cell['mmy']))))
		if steps == 0:
			self.setGridLocation(hitx, hity, 1.0)
			return

		# X position
		stepx												= run / float(steps)
		if abs(stepx) > self.cell['mmx']:
			stepx											= self.cell['mmx']
			if run < 0:
				stepx										*= -1
		# Y position
		stepy												= rise / float(steps)
		if abs(stepy) > self.cell['mmy']:
			stepy											= self.cell['mmy']
			if rise < 0:
				stepy										*= -1

		currx												= self.center['cx']
		curry												= self.center['cy']
		for step in range(steps):
			curry											+= stepy
			currx											+= stepx
			self.setGridLocation(currx, curry, 0.0)
		if rebound:
			self.setGridLocation(hitx, hity, 1.0)
		else:
			self.setGridLocation(hitx, hity, 0.0)

	def setGridLocation(self, x, y, value):
		if x >= 0:
			xpos											= int((x/self.cell['mmx'])+self.center['cx'])
		else:
			xpos											= int((x/self.cell['mmx'])+self.center['cx']+0.91)
		if y >= 0:
			ypos											= int((y/self.cell['mmy'])+self.center['cy'])
		else:
			ypos											= int((y/self.cell['mmy'])+self.center['cy']+0.91)

		if self.inRange(ypos, xpos):
			self.grid[ypos][xpos]							= value
		else:
			# Invalid grid location
			print 'Invalid grid location'
			pass
